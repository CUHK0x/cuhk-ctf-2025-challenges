## \[Crypto] Trustworthy Person
> Expected Difficulty: 4

This challenge is a challenge on Elliptic Curve Cryptography (ECC) and Zero-Knowledge Proofs (ZKP). Let's have a look at the provided code.

`SquigglyStuff.py` contains the implementation of Elliptic Curve (Squiggle) and Point.

There shouldn't be any issues with the implementation there. If yes, then congratulations for finding an unintended bug.

The main code is in `chal.py`, which implements a ZKP protocol to prove the knowledge of the discrete logarithm of a point on the elliptic curve.

The protocol is as follows:

The prover and verifier both know the elliptic curve parameters (secp256k1), the base point $G$, and a public point $Q = dG$. The prover knows the private key $d$ and would like to prove this knowledge to the verifier without revealing $d$.

1. The verifier chooses a random point $P$ on the curve and a random integer $k$.
2. The verifier computes $C1 = kG$ and $C2 = P + kQ$.
3. The verifier sends $C1$ and $C2$ to the prover.
4. The prover computes $C2 - dC1$ and sends the result back to the verifier.
5. The verifier checks if the result equals $P$.
6. Repeat the above steps multiple times to reduce the probability of cheating (10 times in the code).

Step 4 and 5 works since $C2 - dC1 = P + kQ - d(kG) = P + k(dG) - d(kG) = P$.

Suppose everything works correctly, the prover can convince the verifier that they know $d$ without revealing it since this protocol works similarly as El Gamal encryption. The verifier cannot derive $d$ from the information given by the prover since the verifier should receive $P$, which is generated by the verifier itself.

Now, as a malicious verifier, we want to get $d$ from the prover. From the protocol, we can get $C2 - dC1$ given arbitrary $C1$ and $C2$.

Using this, if we want to find $dP$ for an arbitrary point $P$, we can set $C1 = -P$ and $C2 = O$, then the prover will tell us $O - d(-P) = dP$. So we can query $dP$ for any point $P$ 10 times. But using this only, it is not sufficient for us to find $d$ within the 30 seconds time limit.

The main vulnerability in the code is that it does not verify if the input points $C1$ and $C2$ are valid points on the curve. This allows us to use invalid curve attacks to get $d$.

Notice that the point addition and multiplication functions does not depend on the value of $b$. If the input points are not validated, we can use points on other curves (such as $y^2 = x^3 + 8$) to get $d$ modulo the order of that curve. We can choose some good points and carry out (slightly-modified) Pohlig-Hellman attack. We can choose 10 different points with different orders to get $d$ modulo the order of those points. Then we can use CRT to get $d$.

We can group some small primes together to reduce the number of queries. If the number of queries is still not enough, we can also use $Q = dG$ as one of the points to get $d$.

There is a slight probability that the emoticons in the code may interfere with the IO, so be careful when implementing the exploit :>

Solve script:

```python
from pwn import *
from SquigglyStuff import Squiggle, Point, deserialize_point
# from tqdm import tqdm

# Precompute some useful results (you can use sage to do this)
p = 2**256 - 2**32 - 2**9 - 2**8 - 2**7 - 2**6 - 2**4 - 1
a = 0
# b is variable...
# F = GF(p)
# E = EllipticCurve(F, [a, b])
# G = E(x, y)
# factor(G.order()) # Factorize the order of the point G, which is also a factor of the order of the curve

# def exploit(x, y):
#     b = (y^2 - x^3) % p
#     if b == 0:
#         return
#     E = EllipticCurve(F, [0, b])
#     G = E(x, y)
#     order = G.order()
#     print(b, order, factor(order), (x, y))

# The equation of the curve is y^2 = x^3 + b since a = 0
# We just need to find some good b values
exploitation_list = [
    # (order, factors, Generator)
    (115792089237316195423570985008687907853031073199722524052490918277602762621571, [109903, 12977017, 383229727], Point(1, 2)),
    (57896044618658097711785492504343953926299326406578432197819248705606044722122, [2 * 20412485227], Point(1, 3)),
    (38597363079105398474523661669562635951234135017402074565436668291433169282997, [3 * 13 * 13 * 3319, 22639], Point(1, 4)),
    (38597363079105398474523661669562635951169632043852868008808083246071635573919, [199 * 18979], Point(2, 34)),
    (4135431758475578407984678036024568137640761304218723702974166807307342139253, [7 * 10903, 5290657, 10833080827], Point(1, 7)),
]
target = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141
E = Squiggle(a, 7, p)
Generator = Point(
    0x79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798,
    0x483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8,
)

# context.log_level = 'debug'
with remote('localhost', 25059) as io:
    information = []
    io.recvuntil(b"Q: ")
    
    Q = deserialize_point(io.recvline().strip().decode())
    log.info(f"Q = dG = {Q}")

    def bsgs(P, G, order):
        log.info(f"Using BSGS to solve for P = kG, P = {P}, G = {G}, k < {order}")
        sqrt_order = int(order**0.5) + 1
        neg_G = E.negate(G)
        table = dict()
        for i in range(sqrt_order):
            table[P] = i
            P = E.add(P, neg_G)

        larger_G = E.mul(sqrt_order, G)
        Acc = Point(None, None)
        for j in range(sqrt_order):
            if Acc in table:
                return (j * sqrt_order + table[Acc]) % order
            Acc = E.add(Acc, larger_G)
        log.error("No solution found when running BSGS")
        return None

    def exploit(order, factor, G):
        if E.mul(order // factor, G) == Point(None, None):
            return None
        io.recvuntil(b"> ")
        io.sendline(b"n")
        io.sendlineafter(b"C1: ", str(E.mul(order // factor, E.negate(G))).encode())
        io.sendlineafter(b"C2: ", str(Point(None, None)).encode())
        io.recvuntil(b"The thing you need is ")
        P = deserialize_point(io.recvline().strip().decode()) # P = -d * C1 = d * G
        # print("Received P:", P, flush=True)

        residue = bsgs(P, E.mul(order // factor, G), factor)
        return (residue, factor) # d % factor = residue

    for order, factors, G in exploitation_list:
        for factor in factors:
            result = exploit(order, factor, G)
            if result is not None:
                information.append(result)
                log.info(f"Found: d mod {factor} = {result[0]}")

    def crt(information):
        def extended_gcd(a, b):
            if a == 0:
                return b, 0, 1
            gcd, x1, y1 = extended_gcd(b % a, a)
            x = y1 - (b // a) * x1
            y = x1
            return gcd, x, y
        def mod_inverse(a, m):
            gcd, x, _ = extended_gcd(a, m)
            if gcd != 1:
                raise ValueError("Inverse doesn't exist")
            return x % m
        def combine(a1, m1, a2, m2):
            gcd, x, y = extended_gcd(m1, m2)
            if (a1 - a2) % gcd != 0:
                raise ValueError("No solution exists")
            lcm = m1 * (m2 // gcd)
            x = (a1 * (m2 // gcd) * mod_inverse(m2 // gcd, m1) + a2 * (m1 // gcd) * mod_inverse(m1 // gcd, m2)) % lcm
            return x, lcm
        a, m = information[0]
        for a2, m2 in information[1:]:
            a, m = combine(a, m, a2, m2)
        return a, m
    residue, modulo = crt(information)
    
    log.info(f"d mod {modulo} = {residue}")

    # d = q * modulo + residue
    # (q * modulo + residue) * G = Q
    
    q = bsgs(E.add(Q, E.mul(-residue, Generator)), E.mul(modulo, Generator), (target - residue) // modulo + 1)
    d = q * modulo + residue

    io.sendlineafter(b"Now do you trust me? OwO", b"y")

    for _ in range(10):
        io.recvuntil(b"C1: ")
        C1 = deserialize_point(io.recvline().strip().decode())
        io.recvuntil(b"C2: ")
        C2 = deserialize_point(io.recvline().strip().decode())
        io.sendlineafter(b"Secret: ", str(E.add(C2, E.mul(-d, C1))).encode())
    
    print(io.recvall())
```

PS: It is also possible that $d$ can be found by finding good points on $y^2 = x^3$ and exploit the singularity of the curve. But I haven't tried that so I am not entirely sure if it works.